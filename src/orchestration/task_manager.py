import asyncio
import logging
from typing import Any

from src.orchestration.task_planner import TaskPlanner
from src.models.response import MultimodalResponse
from src.models.provider import ModelClient
from src.orchestration.prompts.refinement_prompt import (
    refine_image_task_template,
    refine_text_task_template,
)
from src.utils.tikz_compiler import compile_tikz

log = logging.getLogger(__name__)
log.setLevel(logging.INFO)
log.addHandler(logging.FileHandler('app.log'))


class TaskManager:
    """Manages subtasks to generate multimodal responses."""

    def __init__(
        self,
        text_element_client: ModelClient,
        image_element_client: ModelClient,
        tikz_element_client: ModelClient,
        task_planner: TaskPlanner,
        refine_tasks: bool = False,
    ) -> None:
        """
        Initialize the orchestrator with necessary 'tools'.

        Parameters
        ----------
        text_element_client : ModelClient
            Client for text generation
        image_element_client : ModelClient
            Client for image generation
        task_planner: TaskPlanner
            Task planner for generating subtasks
        refine_tasks : bool
            Whether to refine the tasks generated by the planner
        """
        self.text_client = text_element_client
        self.image_client = image_element_client
        self.tikz_client = tikz_element_client
        self.planner = task_planner
        self.refine_tasks = refine_tasks

    async def generate_response_element(
        self, task: dict[str, str]
    ) -> tuple[int, str, Any]:
        """
        Generate a response element (text or image) to the given prompt.

        Parameters
        ----------
        task : dict[str, str]
            _description_

        Returns
        -------
        tuple[int, str, Any]
            Tuple of the order of the response element and the element itself
        """
        element_order = task.get('order')
        task_type = task.get('type')
        task_prompt = task.get('prompt')

        if task_type == 'text':
            content = await self.text_client.generate_text(task_prompt)

        elif task_type == 'image':
            content = {}
            content['url'] = await self.image_client.generate_image(
                prompt=task_prompt
            )
            content['alt_text'] = task.get('alt_text')
            content['caption'] = task.get('caption')

        elif task_type == 'tikz':
            content = {}
            tikz_code = await self.tikz_client.generate_tikz(
                prompt=task_prompt
            )

            tikz_image_path = compile_tikz(tikz_code)

            content['code'] = tikz_code
            content['image_path'] = tikz_image_path
            content['alt_text'] = task.get('alt_text')
            content['caption'] = task.get('caption')

        return element_order, task_type, content

    async def _refine_subtask_prompts(
        self,
        user_prompt: str,
        task_type: str,
        task_description: str,
        task_prompt: str,
        before_context: str,
        after_context: str,
        order: int,
        alt_text: str | None = None,
        caption: str | None = None,
    ) -> dict[str, Any]:
        refine_prompt = self.refinement_prompt[task_type].format(
            user_prompt=user_prompt,
            task_prompt=task_prompt,
            # before_context=before_context,
            # after_context=after_context,
        )
        response = await self.text_client.generate_text(prompt=refine_prompt)

        # reconstruct subtask with refined prompt
        subtask = {
            'type': task_type,
            'description': task_description,
            'prompt': response,
            'alt_text': alt_text,
            'caption': caption,
            'order': order,
        }
        return subtask

    async def _refine_subtasks(
        self,
        user_prompt: str,
        subtasks: list[dict[str, Any]],
    ) -> list[dict[str, Any]]:
        num_subtasks = len(subtasks)

        refinement_tasks = [
            asyncio.create_task(
                self._refine_subtask_prompts(
                    user_prompt=user_prompt,
                    task_type=task.get('type'),
                    task_description=task.get('description'),
                    task_prompt=task.get('prompt'),
                    before_context=(
                        subtasks[i - 1].get('description')
                        if i > 0
                        else 'is the beginning of the response'
                    ),
                    after_context=(
                        subtasks[i + 1].get('description')
                        if i < num_subtasks - 1
                        else 'is the end of the response'
                    ),
                    order=i,
                    alt_text=task.get('alt_text'),
                    caption=task.get('caption'),
                )
            )
            for i, task in enumerate(subtasks)
        ]

        refined_subtasks = await asyncio.gather(*refinement_tasks)
        refined_subtasks.sort(key=lambda x: x.get('order', 0))
        return refined_subtasks

    async def generate_response(self, prompt: str) -> MultimodalResponse:
        """Generate a multimodal response to the given prompt.

        Args:
            prompt: User's input prompt

        Returns:
            A MultimodalResponse containing the interleaved text and image elements
        """
        # Plan the response
        subtasks = await self.planner.generate_plan(prompt)
        log.info(f'Planned subtasks: {subtasks}')

        # Sort subtasks by order
        subtasks.sort(key=lambda x: x.get('order', 0))

        # Refine the tasks if needed
        if self.refine_tasks:
            # Refine the tasks
            self.refinement_prompt = {
                'text': refine_text_task_template,
                'image': refine_image_task_template,
            }
            subtasks = await self._refine_subtasks(prompt, subtasks)
            log.info(f'Refined subtasks: {subtasks}')

        # Execute each subtask
        response = MultimodalResponse()

        response_tasks = [
            self.generate_response_element(task) for task in subtasks
        ]
        elements = await asyncio.gather(*response_tasks)
        sorted_elements = sorted(elements, key=lambda x: x[0])
        for element in sorted_elements:
            response.add_element(type=element[1], content=element[2])

        return response
