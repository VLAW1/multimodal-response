import sys
import os
from pathlib import Path

# Add the project root to the path so we can import the utils
sys.path.insert(0, str(Path(__file__).resolve().parents[3]))
from src.utils.tikz_compiler import compile_tikz

tikz_prompt_template = (
    'Create precise TikZ code for LaTeX that generates a figure based on this'
    ' description:'
    '\n\n'
    '{prompt}'
    '\n\n'
    'Return only the complete TikZ code that would go between'
    ' \\begin{{tikzpicture}} and \\end{{tikzpicture}}.\n'
    'Include proper \\usetikzlibrary commands for any libraries needed.\n'
    'The code should be compilable with pdflatex and should not require any'
    ' special packages other than TikZ.'
)

tikz_examples = [
    {
        'prompt': (
            'Create a precise TikZ diagram showing the RSA encryption'
            ' process. Include: 1) Key generation with prime numbers p and q,'
            ' computing n=pq and totient=(p-1)(q-1), selecting e and computing'
            ' d such that ed â‰¡ 1 (mod totient). 2) Encryption process with'
            ' C=M^e mod n. 3) Decryption with M=C^d mod n. Use proper'
            ' mathematical notation and organize as a flowchart with three'
            ' distinct sections.'
        ),
        'response': (
            '\\begin{{tikzpicture}}[\n'
            '  box/.style={rectangle, draw, rounded corners, minimum width=4cm, minimum height=1.5cm, align=center},\n'
            '  arrow/.style={thick, ->, >=stealth},\n'
            '  title/.style={font=\\bfseries\\large}\n'
            ']\n'
            '\n'
            '% Title for each section\n'
            '\\node[title] at (0,8) {Key Generation};\n'
            '\\node[title] at (8,8) {Encryption (Public Key)};\n'
            '\\node[title] at (16,8) {Decryption (Private Key)};\n'
            '\n'
            '% Key Generation Section\n'
            '\\node[box] (step1) at (0,6) {Choose large prime numbers\\\\$p$ and $q$};\n'
            '\\node[box] (step2) at (0,4) {Compute modulus\\\\$n = p \times q$};\n'
            "\\node[box] (step3) at (0,2) {Calculate Euler's totient\\\\$\\phi(n) = (p-1)(q-1)$};\n"
            '\\node[box] (step4) at (0,0) {Choose $e$ such that\\\\$\\gcd(e,\\phi(n)) = 1$};\n'
            '\\node[box] (step5) at (0,-2) {Calculate $d$ such that\\\\$e \\cdot d \\equiv 1 \\pmod{\\phi(n)}$};\n'
            '\n'
            '\\draw[arrow] (step1) -- (step2);\n'
            '\\draw[arrow] (step2) -- (step3);\n'
            '\\draw[arrow] (step3) -- (step4);\n'
            '\\draw[arrow] (step4) -- (step5);\n'
            '\n'
            '% Results of key generation\n'
            '\\node[box, fill=green!10] (pubkey) at (0,-4) {Public Key: $(n,e)$};\n'
            '\\node[box, fill=red!10] (privkey) at (0,-6) {Private Key: $(n,d)$};\n'
            '\n'
            '\\draw[arrow] (step5) -- (pubkey);\n'
            '\\draw[arrow] (step5) -- (privkey);\n'
            '\n'
            '% Encryption Section\n'
            '\\node[box] (message) at (8,6) {Original Message\\\\$M$};\n'
            '\\node[box] (encrypt) at (8,3) {Apply Formula:\\\\$C = M^e \\bmod n$};\n'
            '\\node[box, fill=blue!10] (cipher) at (8,0) {Ciphertext\\\\$C$};\n'
            '\n'
            '\\draw[arrow] (message) -- (encrypt);\n'
            '\\draw[arrow] (encrypt) -- (cipher);\n'
            '\\draw[arrow, dashed] (pubkey) to[bend left] node[above,sloped] {Use public key} (encrypt);\n'
            '\n'
            '% Decryption Section\n'
            '\\node[box] (cipher2) at (16,6) {Ciphertext\\\\$C$};\n'
            '\\node[box] (decrypt) at (16,3) {Apply Formula:\\\\$M = C^d \\bmod n$};\n'
            '\\node[box, fill=green!10] (message2) at (16,0) {Original Message\\$M$};\n'
            '\n'
            '\\draw[arrow] (cipher2) -- (decrypt);\n'
            '\\draw[arrow] (decrypt) -- (message2);\n'
            '\\draw[arrow, dashed] (privkey) to[bend right] node[above,sloped] {Use private key} (decrypt);\n'
            '\n'
            '% Separator lines between sections\n'
            '\\draw[thick, dashed] (4,-7) -- (4,9);\n'
            '\\draw[thick, dashed] (12,-7) -- (12,9);\n'
            '\n'
            '\\end{{tikzpicture}}'
        ),
    },
    {
        'prompt': (
            'Create a TikZ diagram of a simplified quantum circuit for'
            " Shor's algorithm. Show the two quantum registers (upper"
            ' register with control qubits and lower register with target'
            ' qubits), the quantum Fourier transform (QFT) applied to the'
            ' first register, the modular exponentiation operations, and'
            ' measurement operations. Use proper quantum circuit notation with'
            ' horizontal lines for qubits and vertical/connecting lines for'
            ' gates.'
        ),
        'response': (
            '\\begin{{tikzpicture}}[\n'
            '  circuit/.style={{thick}},\n'
            '  classical/.style={thick,double,double distance=1pt},\n'
            '  measure/.style={draw, fill=white, minimum width=0.5cm, minimum height=0.5cm},\n'
            '  gate/.style={draw, fill=white, minimum width=0.5cm, minimum height=0.5cm},\n'
            '  biggate/.style={draw, fill=white, minimum width=1.5cm, minimum height=1.8cm},\n'
            '  >=stealth\n'
            ']\n'
            '\n'
            '% Register labels\n'
            '\\node at (-1.5, 0) {$|0\\rangle^{\\otimes n}$};\n'
            '\\node at (-1.5, -3) {$|1\\rangle$};\n'
            '\n'
            '% Horizontal lines for qubits (top register)\n'
            '\\foreach \\y in {0,...,4} {\n'
            '    \\draw[circuit] (-0.5, -\\y*0.5) -- (11, -\\y*0.5);\n'
            '}\n'
            '\n'
            '% Bottom register line\n'
            '\\draw[circuit] (-0.5, -3) -- (11, -3);\n'
            '\n'
            '% QFT - Quantum Fourier Transform\n'
            '\\draw[gate, fill=blue!10] (2, -1) rectangle (4, 0.5);\n'
            '\\node at (3, -0.25) {{QFT}};\n'
            '\n'
            '% Control gates from top register to bottom\n'
            '\\foreach \\x/\\y in {5.5/0, 6.5/-0.5, 7.5/-1, 8.5/-1.5, 9.5/-2} {\n'
            '    \\draw[circuit] (\\x, \\y) -- (\\x, -3);\n'
            '    \\filldraw (\\x, \\y) circle (0.1);\n'
            '    \\draw[gate] (\\x-0.25, -3-0.25) rectangle (\\x+0.25, -3+0.25);\n'
            '    \\node at (\\x, -3) {$U^{2^i}$};\n'
            '}\n'
            '\n'
            '% Controlled operation box\n'
            '\\draw[biggate, fill=yellow!10] (5, -3.75) rectangle (10, -2.25);\n'
            '\\node at (7.5, -3) {Modular Exponentiation};\n'
            '\n'
            '% Inverse QFT\n'
            '\\draw[gate, fill=blue!10] (10.5, -1) rectangle (12.5, 0.5);\n'
            '\\node at (11.5, -0.25) {QFT$^{-1}$};\n'
            '\n'
            '% Measurements on top register\n'
            '\\foreach \\y in {0,...,4} {\n'
            '    \\draw[measure, fill=gray!20] (13, -\\y*0.5-0.25) rectangle (13.5, -\\y*0.5+0.25);\n'
            '    \\draw (13.25, -\\y*0.5-0.25) -- (13.25, -\\y*0.5+0.25) -- (13.5, -\\y*0.5);\n'
            '}\n'
            '\n'
            '% Lines connecting to measurements\n'
            '\\foreach \\y in {0,...,4} {\n'
            '    \\draw[circuit] (12.5, -\\y*0.5) -- (13, -\\y*0.5);\n'
            '}\n'
            '\n'
            '% Classical lines from measurements\n'
            '\\foreach \\y in {0,...,4} {\n'
            '    \\draw[classical] (13.5, -\\y*0.5) -- (14.5, -\\y*0.5);\n'
            '}\n'
            '\n'
            '% Labels\n'
            '\\node[align=center] at (3, 1.5) {Phase 1:\\\\Quantum Fourier\\\\Transform};\n'
            '\\node[align=center] at (7.5, 1.5) {Phase 2:\\\\Apply controlled-$U^{2^j}$\\\\operations};\n'
            '\\node[align=center] at (11.5, 1.5) {Phase 3:\\\\Inverse Quantum\\\\fourier Transform};\n'
            '\\node[align=center] at (13.25, 1.5) {Phase 4:\\\\Measurement};\n'
            '\n'
            '\\end{{tikzpicture}}\n'
        ),
    },
    {
        'prompt': (
            'Create a TikZ plot comparing the runtime complexity of'
            " classical factoring algorithms versus Shor's quantum algorithm."
            ' Use a logarithmic scale y-axis (runtime) and linear x-axis'
            ' (number of bits). Plot the General Number Field Sieve complexity'
            ' O(exp((64/9)^(1/3) * (log n)^(1/3) * (log log n)^(2/3))) in red'
            " and Shor's algorithm complexity O(log^3 n) in blue. Use a range"
            ' of 256 to 4096 bits for RSA keys. Include a legend and properly'
            ' labeled axes with grid lines.'
        ),
        'response': (
            '\\begin{{tikzpicture}}\n'
            '% Setup the plot with logarithmic scale\n'
            '\\begin{loglogaxis}[\n'
            '    xlabel={RSA Key Size (bits)},\n'
            '    ylabel={Runtime (arbitrary units)},\n'
            '    xmin=256, xmax=4096,\n'
            '    ymin=1, ymax=10^20,\n'
            '    grid=both,\n'
            '    minor grid style={gray!25},\n'
            '    major grid style={gray!50},\n'
            '    width=12cm,\n'
            '    height=9cm,\n'
            '    legend pos=north west,\n'
            '    log basis x=2,\n'
            '    xtick={256,512,1024,2048,4096},\n'
            '    xticklabels={256,512,1024,2048,4096},\n'
            '    title={Runtime Comparison: Classical vs Quantum Factoring}\n'
            ']\n'
            '\n'
            '% Define complex classical factoring algorithm (GNFS)\n'
            '\\addplot[\n'
            '    domain=256:4096,\n'
            '    samples=50,\n'
            '    red,\n'
            '    thick,\n'
            '] {exp((64/9)^(1/3) * (ln(x)/ln(2))^(1/3) * (ln(ln(x)/ln(2)))^(2/3))};\n'
            '\\addlegendentry{Classical (GNFS)}\n'
            '\n'
            "% Define Shor's algorithm\n"
            '\\addplot[\n'
            '    domain=256:4096,\n'
            '    samples=50,\n'
            '    blue,\n'
            '    thick,\n'
            '    dashed\n'
            '] {(ln(x)/ln(2))^3};\n'
            "\\addlegendentry{Quantum (Shor's)}\n"
            '\n'
            '% Add some annotations\n'
            '\\node[red, align=right] at (axis cs:1024,10^15) {Exponential growth with key size};\n'
            '\\node[blue, align=left] at (axis cs:2048,10^5) {Polynomial growth with key size};\n'
            '\n'
            '% Add a vertical line at currently common RSA key size\n'
            '\\draw[thick, gray, dashed] (axis cs:2048,1) -- (axis cs:2048,10^20);\n'
            '\\node[rotate=90, gray] at (axis cs:2048,10^10) {Current standard RSA key size};\n'
            '\n'
            '\\end{{loglogaxis}}\n'
            '\\end{{tikzpicture}}\n'
        ),
    },
    {
        'prompt': (
            'Create a TikZ heat map visualization showing the vulnerability'
            ' of different cryptographic algorithms to quantum attacks. Use a'
            ' grid with algorithms on the y-axis (RSA-2048, RSA-4096, ECC-256,'
            ' ECC-384, AES-128, AES-256, SHA-256, SHA-3, NTRU, Dilithium,'
            ' Saber, etc.) and vulnerability level on the x-axis. Use color'
            ' gradient from green (resistant) to red (vulnerable). Include a'
            ' colored legend explaining the vulnerability scale and group the'
            ' algorithms by type (asymmetric, symmetric, hash functions,'
            ' post-quantum).'
        ),
        'response': (
            '\\begin{tikzpicture}[scale=0.9]\n'
            '% Define the heat map colors\n'
            '\\definecolor{{safe}}{{RGB}}{40,180,99}     % Green - resistant\n'
            '\\definecolor{{moderate}}{{RGB}}{255,255,51} % Yellow - moderate risk\n'
            '\\definecolor{{vulnerable}}{{RGB}}{231,76,60}  % Red - vulnerable\n'
            '\n'
            '% Create the chart\n'
            '\\begin{{axis}}[\n'
            '    title={Vulnerability of Cryptographic Methods to Quantum Computing},\n'
            '    xlabel={Vulnerability Level},\n'
            '    ylabel={{Algorithm}},\n'
            '    ytick=data,\n'
            '    symbolic y coords={RSA-2048, RSA-4096, ECC-256, ECC-384, AES-128, AES-256, SHA-256, SHA-3, NTRU, Dilithium, Saber, Kyber, Falcon},\n'
            '    xmin=0, xmax=100,\n'
            '    xtick={0,25,50,75,100},\n'
            '    xticklabels={Resistant, Low, Moderate, High, Critical},\n'
            '    xticklabel style={rotate=45, anchor=east},\n'
            '    height=12cm,\n'
            '    width=15cm,\n'
            '    enlarge y limits=0.1,\n'
            '    enlarge x limits=0.05,\n'
            '    y dir=reverse,\n'
            '    yticklabel style={font=\\small},\n'
            '    legend pos=south east,\n'
            '    point meta min=0,\n'
            '    point meta max=100,\n'
            '    colorbar,\n'
            '    colormap={{vulnmap}}{color(0)=(safe); color(0.4)=(moderate); color(1)=(vulnerable)},\n'
            '    colorbar style={\n'
            '        ytick={0,25,50,75,100},\n'
            '        yticklabels={Resistant, Low, Moderate, High, Critical},\n'
            '    }\n'
            ']\n'
            '\n'
            '% Group: Asymmetric traditional\n'
            '\\addplot[area legend, point meta=explicit, fill opacity=0.8] \n'
            '    coordinates {\n'
            '        (95,RSA-2048) [95]\n'
            '        (90,RSA-4096) [90]\n'
            '        (95,ECC-256) [95]\n'
            '        (90,ECC-384) [90]\n'
            '    };\n'
            '\n'
            '% Group: Symmetric key\n'
            '\\addplot[point meta=explicit, fill opacity=0.8] \n'
            '    coordinates {\n'
            '        (30,AES-128) [30]\n'
            '        (10,AES-256) [10]\n'
            '    };\n'
            '\n'
            '% Group: Hash functions\n'
            '\\addplot[point meta=explicit, fill opacity=0.8] \n'
            '    coordinates {\n'
            '        (45,SHA-256) [45]\n'
            '        (20,SHA-3) [20]\n'
            '    };\n'
            '\n'
            '% Group: Post-quantum\n'
            '\\addplot[point meta=explicit, fill opacity=0.8] \n'
            '    coordinates {\n'
            '        (10,NTRU) [10]\n'
            '        (5,Dilithium) [5]\n'
            '        (15,Saber) [15]\n'
            '        (5,Kyber) [5]\n'
            '        (10,Falcon) [10]\n'
            '    };\n'
            '\n'
            '% Add algorithm type grouping brackets\n'
            '\\draw[thick, decorate, decoration={brace, amplitude=10pt}] \n'
            '    (axis cs:-5,RSA-2048) -- (axis cs:-5,ECC-384) \n'
            '    node[midway, left=15pt, align=center] {Traditional\\Asymmetric};\n'
            '    \n'
            '\\draw[thick, decorate, decoration={brace, amplitude=10pt}] \n'
            '    (axis cs:-5,AES-128) -- (axis cs:-5,AES-256)\n'
            '    node[midway, left=15pt] {{Symmetric}};\n'
            '\n'
            '\\draw[thick, decorate, decoration={brace, amplitude=10pt}] \n'
            '    (axis cs:-5,SHA-256) -- (axis cs:-5,SHA-3)\n'
            '    node[midway, left=15pt] {{Hash}};\n'
            '\n'
            '\\draw[thick, decorate, decoration={brace, amplitude=10pt}] \n'
            '    (axis cs:-5,NTRU) -- (axis cs:-5,Falcon)\n'
            '    node[midway, left=15pt, align=center] {Post-\\Quantum};\n'
            '\n'
            '\\end{{axis}}\n'
            '\\end{{tikzpicture}}\n'
        ),
    },
]


if __name__ == '__main__':
    # test compiling the responses

    # Create a test directory for the compiled images
    test_dir = 'tikz_test_images'
    os.makedirs(test_dir, exist_ok=True)

    print(f'Testing TikZ compilation for {len(tikz_examples)} examples...')

    for i, example in enumerate(tikz_examples):
        print(f'\nExample {i + 1}: {example["prompt"][:50]}...')

        # Extract the tikz code from the response
        tikz_code = example['response']

        # Compile the TikZ code
        output_path = compile_tikz(tikz_code, output_dir=test_dir)

        if output_path:
            print(f'Successfully compiled. Output saved to: {output_path}')
        else:
            print(f'Compilation failed for Example {i + 1}')

    print('\nTesting complete!')
    print(f'All images saved to: {os.path.abspath(test_dir)}')
